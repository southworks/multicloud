"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parameterVisitor = parameterVisitor;

var _core = require("@babel/core");

function parameterVisitor(classPath, path) {
  if (path.type !== 'ClassMethod') return;
  if (path.node.type !== 'ClassMethod') return;
  if (path.node.key.type !== 'Identifier') return;
  const methodPath = path;
  const methodName = path.node.key.name;
  const params = methodPath.get('params') || [];
  params.slice().forEach(function (param) {
    let identifier = param.node.type === 'Identifier' ? param.node : param.node.type === 'TSParameterProperty' && param.node.parameter.type === 'Identifier' ? param.node.parameter : null;
    if (identifier == null) return;
    let resultantDecorator;
    (param.node.decorators || []).slice().forEach(function (decorator) {
      const className = classPath.node.id.name;

      if (methodPath.node.kind === 'constructor') {
        resultantDecorator = _core.types.callExpression(decorator.expression, [_core.types.identifier(className), _core.types.identifier('undefined'), _core.types.numericLiteral(param.key)]);
      } else {
        resultantDecorator = _core.types.callExpression(decorator.expression, [_core.types.identifier(`${className}.prototype`), _core.types.stringLiteral(methodName), _core.types.numericLiteral(param.key)]);
      }

      const expression = _core.types.expressionStatement(resultantDecorator);

      classPath.insertAfter(expression);
    });

    if (resultantDecorator) {
      param.node.decorators = null;
    }
  });
}